// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/monitoring/v3/uptime.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.Monitoring.V3 {

  /// <summary>Holder for reflection information generated from google/monitoring/v3/uptime.proto</summary>
  public static partial class UptimeReflection {

    #region Descriptor
    /// <summary>File descriptor for google/monitoring/v3/uptime.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static UptimeReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiFnb29nbGUvbW9uaXRvcmluZy92My91cHRpbWUucHJvdG8SFGdvb2dsZS5t",
            "b25pdG9yaW5nLnYzGiNnb29nbGUvYXBpL21vbml0b3JlZF9yZXNvdXJjZS5w",
            "cm90bxoeZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnByb3RvIuoIChFVcHRp",
            "bWVDaGVja0NvbmZpZxIMCgRuYW1lGAEgASgJEhQKDGRpc3BsYXlfbmFtZRgC",
            "IAEoCRI7ChJtb25pdG9yZWRfcmVzb3VyY2UYAyABKAsyHS5nb29nbGUuYXBp",
            "Lk1vbml0b3JlZFJlc291cmNlSAASTwoOcmVzb3VyY2VfZ3JvdXAYBCABKAsy",
            "NS5nb29nbGUubW9uaXRvcmluZy52My5VcHRpbWVDaGVja0NvbmZpZy5SZXNv",
            "dXJjZUdyb3VwSAASRwoKaHR0cF9jaGVjaxgFIAEoCzIxLmdvb2dsZS5tb25p",
            "dG9yaW5nLnYzLlVwdGltZUNoZWNrQ29uZmlnLkh0dHBDaGVja0gBEkUKCXRj",
            "cF9jaGVjaxgGIAEoCzIwLmdvb2dsZS5tb25pdG9yaW5nLnYzLlVwdGltZUNo",
            "ZWNrQ29uZmlnLlRjcENoZWNrSAESKQoGcGVyaW9kGAcgASgLMhkuZ29vZ2xl",
            "LnByb3RvYnVmLkR1cmF0aW9uEioKB3RpbWVvdXQYCCABKAsyGS5nb29nbGUu",
            "cHJvdG9idWYuRHVyYXRpb24SUAoQY29udGVudF9tYXRjaGVycxgJIAMoCzI2",
            "Lmdvb2dsZS5tb25pdG9yaW5nLnYzLlVwdGltZUNoZWNrQ29uZmlnLkNvbnRl",
            "bnRNYXRjaGVyEkEKEHNlbGVjdGVkX3JlZ2lvbnMYCiADKA4yJy5nb29nbGUu",
            "bW9uaXRvcmluZy52My5VcHRpbWVDaGVja1JlZ2lvbhphCg1SZXNvdXJjZUdy",
            "b3VwEhAKCGdyb3VwX2lkGAEgASgJEj4KDXJlc291cmNlX3R5cGUYAiABKA4y",
            "Jy5nb29nbGUubW9uaXRvcmluZy52My5Hcm91cFJlc291cmNlVHlwZRrkAgoJ",
            "SHR0cENoZWNrEg8KB3VzZV9zc2wYASABKAgSDAoEcGF0aBgCIAEoCRIMCgRw",
            "b3J0GAMgASgFElgKCWF1dGhfaW5mbxgEIAEoCzJFLmdvb2dsZS5tb25pdG9y",
            "aW5nLnYzLlVwdGltZUNoZWNrQ29uZmlnLkh0dHBDaGVjay5CYXNpY0F1dGhl",
            "bnRpY2F0aW9uEhQKDG1hc2tfaGVhZGVycxgFIAEoCBJPCgdoZWFkZXJzGAYg",
            "AygLMj4uZ29vZ2xlLm1vbml0b3JpbmcudjMuVXB0aW1lQ2hlY2tDb25maWcu",
            "SHR0cENoZWNrLkhlYWRlcnNFbnRyeRo5ChNCYXNpY0F1dGhlbnRpY2F0aW9u",
            "EhAKCHVzZXJuYW1lGAEgASgJEhAKCHBhc3N3b3JkGAIgASgJGi4KDEhlYWRl",
            "cnNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBGhgKCFRj",
            "cENoZWNrEgwKBHBvcnQYASABKAUaIQoOQ29udGVudE1hdGNoZXISDwoHY29u",
            "dGVudBgBIAEoCUIKCghyZXNvdXJjZUIUChJjaGVja19yZXF1ZXN0X3R5cGUi",
            "bgoNVXB0aW1lQ2hlY2tJcBI3CgZyZWdpb24YASABKA4yJy5nb29nbGUubW9u",
            "aXRvcmluZy52My5VcHRpbWVDaGVja1JlZ2lvbhIQCghsb2NhdGlvbhgCIAEo",
            "CRISCgppcF9hZGRyZXNzGAMgASgJKmUKEVVwdGltZUNoZWNrUmVnaW9uEhYK",
            "ElJFR0lPTl9VTlNQRUNJRklFRBAAEgcKA1VTQRABEgoKBkVVUk9QRRACEhEK",
            "DVNPVVRIX0FNRVJJQ0EQAxIQCgxBU0lBX1BBQ0lGSUMQBCpbChFHcm91cFJl",
            "c291cmNlVHlwZRIdChlSRVNPVVJDRV9UWVBFX1VOU1BFQ0lGSUVEEAASDAoI",
            "SU5TVEFOQ0UQARIZChVBV1NfRUxCX0xPQURfQkFMQU5DRVIQAkKGAQoYY29t",
            "Lmdvb2dsZS5tb25pdG9yaW5nLnYzQgtVcHRpbWVQcm90b1ABWj5nb29nbGUu",
            "Z29sYW5nLm9yZy9nZW5wcm90by9nb29nbGVhcGlzL21vbml0b3JpbmcvdjM7",
            "bW9uaXRvcmluZ6oCGkdvb2dsZS5DbG91ZC5Nb25pdG9yaW5nLlYzYgZwcm90",
            "bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.MonitoredResourceReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Google.Cloud.Monitoring.V3.UptimeCheckRegion), typeof(global::Google.Cloud.Monitoring.V3.GroupResourceType), }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.UptimeCheckConfig), global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Parser, new[]{ "Name", "DisplayName", "MonitoredResource", "ResourceGroup", "HttpCheck", "TcpCheck", "Period", "Timeout", "ContentMatchers", "SelectedRegions" }, new[]{ "Resource", "CheckRequestType" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ResourceGroup), global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ResourceGroup.Parser, new[]{ "GroupId", "ResourceType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck), global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck.Parser, new[]{ "UseSsl", "Path", "Port", "AuthInfo", "MaskHeaders", "Headers" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck.Types.BasicAuthentication), global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck.Types.BasicAuthentication.Parser, new[]{ "Username", "Password" }, null, null, null),
            null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.TcpCheck), global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.TcpCheck.Parser, new[]{ "Port" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ContentMatcher), global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ContentMatcher.Parser, new[]{ "Content" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.UptimeCheckIp), global::Google.Cloud.Monitoring.V3.UptimeCheckIp.Parser, new[]{ "Region", "Location", "IpAddress" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// The regions from which an uptime check can be run.
  /// </summary>
  public enum UptimeCheckRegion {
    /// <summary>
    /// Default value if no region is specified. Will result in uptime checks
    /// running from all regions.
    /// </summary>
    [pbr::OriginalName("REGION_UNSPECIFIED")] RegionUnspecified = 0,
    /// <summary>
    /// Allows checks to run from locations within the United States of America.
    /// </summary>
    [pbr::OriginalName("USA")] Usa = 1,
    /// <summary>
    /// Allows checks to run from locations within the continent of Europe.
    /// </summary>
    [pbr::OriginalName("EUROPE")] Europe = 2,
    /// <summary>
    /// Allows checks to run from locations within the continent of South
    /// America.
    /// </summary>
    [pbr::OriginalName("SOUTH_AMERICA")] SouthAmerica = 3,
    /// <summary>
    /// Allows checks to run from locations within the Asia Pacific area (ex:
    /// Singapore).
    /// </summary>
    [pbr::OriginalName("ASIA_PACIFIC")] AsiaPacific = 4,
  }

  /// <summary>
  /// The supported resource types that can be used as values of
  /// group_resource.resource_type. gae_app and uptime_url are not allowed
  /// because group checks on App Engine modules and URLs are not allowed.
  /// </summary>
  public enum GroupResourceType {
    /// <summary>
    /// Default value (not valid).
    /// </summary>
    [pbr::OriginalName("RESOURCE_TYPE_UNSPECIFIED")] ResourceTypeUnspecified = 0,
    /// <summary>
    /// A group of instances (could be either GCE or AWS_EC2).
    /// </summary>
    [pbr::OriginalName("INSTANCE")] Instance = 1,
    /// <summary>
    /// A group of AWS load balancers.
    /// </summary>
    [pbr::OriginalName("AWS_ELB_LOAD_BALANCER")] AwsElbLoadBalancer = 2,
  }

  #endregion

  #region Messages
  /// <summary>
  /// This message configures which resources and services to monitor for
  /// availability.
  /// </summary>
  public sealed partial class UptimeCheckConfig : pb::IMessage<UptimeCheckConfig> {
    private static readonly pb::MessageParser<UptimeCheckConfig> _parser = new pb::MessageParser<UptimeCheckConfig>(() => new UptimeCheckConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UptimeCheckConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Monitoring.V3.UptimeReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UptimeCheckConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UptimeCheckConfig(UptimeCheckConfig other) : this() {
      name_ = other.name_;
      displayName_ = other.displayName_;
      Period = other.period_ != null ? other.Period.Clone() : null;
      Timeout = other.timeout_ != null ? other.Timeout.Clone() : null;
      contentMatchers_ = other.contentMatchers_.Clone();
      selectedRegions_ = other.selectedRegions_.Clone();
      switch (other.ResourceCase) {
        case ResourceOneofCase.MonitoredResource:
          MonitoredResource = other.MonitoredResource.Clone();
          break;
        case ResourceOneofCase.ResourceGroup:
          ResourceGroup = other.ResourceGroup.Clone();
          break;
      }

      switch (other.CheckRequestTypeCase) {
        case CheckRequestTypeOneofCase.HttpCheck:
          HttpCheck = other.HttpCheck.Clone();
          break;
        case CheckRequestTypeOneofCase.TcpCheck:
          TcpCheck = other.TcpCheck.Clone();
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UptimeCheckConfig Clone() {
      return new UptimeCheckConfig(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// A unique resource name for this UptimeCheckConfig. The format is:
    ///
    ///   `projects/[PROJECT_ID]/uptimeCheckConfigs/[UPTIME_CHECK_ID]`.
    ///
    /// This field should be omitted when creating the uptime check configuration;
    /// on create, the resource name is assigned by the server and included in the
    /// response.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "display_name" field.</summary>
    public const int DisplayNameFieldNumber = 2;
    private string displayName_ = "";
    /// <summary>
    /// A human-friendly name for the uptime check configuration. The display name
    /// should be unique within a Stackdriver Account in order to make it easier
    /// to identify; however, uniqueness is not enforced. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DisplayName {
      get { return displayName_; }
      set {
        displayName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "monitored_resource" field.</summary>
    public const int MonitoredResourceFieldNumber = 3;
    /// <summary>
    /// The monitored resource associated with the configuration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Api.MonitoredResource MonitoredResource {
      get { return resourceCase_ == ResourceOneofCase.MonitoredResource ? (global::Google.Api.MonitoredResource) resource_ : null; }
      set {
        resource_ = value;
        resourceCase_ = value == null ? ResourceOneofCase.None : ResourceOneofCase.MonitoredResource;
      }
    }

    /// <summary>Field number for the "resource_group" field.</summary>
    public const int ResourceGroupFieldNumber = 4;
    /// <summary>
    /// The group resource associated with the configuration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ResourceGroup ResourceGroup {
      get { return resourceCase_ == ResourceOneofCase.ResourceGroup ? (global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ResourceGroup) resource_ : null; }
      set {
        resource_ = value;
        resourceCase_ = value == null ? ResourceOneofCase.None : ResourceOneofCase.ResourceGroup;
      }
    }

    /// <summary>Field number for the "http_check" field.</summary>
    public const int HttpCheckFieldNumber = 5;
    /// <summary>
    /// Contains information needed to make an HTTP or HTTPS check.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck HttpCheck {
      get { return checkRequestTypeCase_ == CheckRequestTypeOneofCase.HttpCheck ? (global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck) checkRequestType_ : null; }
      set {
        checkRequestType_ = value;
        checkRequestTypeCase_ = value == null ? CheckRequestTypeOneofCase.None : CheckRequestTypeOneofCase.HttpCheck;
      }
    }

    /// <summary>Field number for the "tcp_check" field.</summary>
    public const int TcpCheckFieldNumber = 6;
    /// <summary>
    /// Contains information needed to make a TCP check.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.TcpCheck TcpCheck {
      get { return checkRequestTypeCase_ == CheckRequestTypeOneofCase.TcpCheck ? (global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.TcpCheck) checkRequestType_ : null; }
      set {
        checkRequestType_ = value;
        checkRequestTypeCase_ = value == null ? CheckRequestTypeOneofCase.None : CheckRequestTypeOneofCase.TcpCheck;
      }
    }

    /// <summary>Field number for the "period" field.</summary>
    public const int PeriodFieldNumber = 7;
    private global::Google.Protobuf.WellKnownTypes.Duration period_;
    /// <summary>
    /// How often the uptime check is performed.
    /// Currently, only 1, 5, 10, and 15 minutes are supported. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration Period {
      get { return period_; }
      set {
        period_ = value;
      }
    }

    /// <summary>Field number for the "timeout" field.</summary>
    public const int TimeoutFieldNumber = 8;
    private global::Google.Protobuf.WellKnownTypes.Duration timeout_;
    /// <summary>
    /// The maximum amount of time to wait for the request to complete (must be
    /// between 1 and 60 seconds). Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration Timeout {
      get { return timeout_; }
      set {
        timeout_ = value;
      }
    }

    /// <summary>Field number for the "content_matchers" field.</summary>
    public const int ContentMatchersFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ContentMatcher> _repeated_contentMatchers_codec
        = pb::FieldCodec.ForMessage(74, global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ContentMatcher.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ContentMatcher> contentMatchers_ = new pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ContentMatcher>();
    /// <summary>
    /// The expected content on the page the check is run against.
    /// Currently, only the first entry in the list is supported, and other entries
    /// will be ignored. The server will look for an exact match of the string in
    /// the page response's content. This field is optional and should only be
    /// specified if a content match is required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ContentMatcher> ContentMatchers {
      get { return contentMatchers_; }
    }

    /// <summary>Field number for the "selected_regions" field.</summary>
    public const int SelectedRegionsFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Google.Cloud.Monitoring.V3.UptimeCheckRegion> _repeated_selectedRegions_codec
        = pb::FieldCodec.ForEnum(82, x => (int) x, x => (global::Google.Cloud.Monitoring.V3.UptimeCheckRegion) x);
    private readonly pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.UptimeCheckRegion> selectedRegions_ = new pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.UptimeCheckRegion>();
    /// <summary>
    /// The list of regions from which the check will be run.
    /// If this field is specified, enough regions to include a minimum of
    /// 3 locations must be provided, or an error message is returned.
    /// Not specifying this field will result in uptime checks running from all
    /// regions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.UptimeCheckRegion> SelectedRegions {
      get { return selectedRegions_; }
    }

    private object resource_;
    /// <summary>Enum of possible cases for the "resource" oneof.</summary>
    public enum ResourceOneofCase {
      None = 0,
      MonitoredResource = 3,
      ResourceGroup = 4,
    }
    private ResourceOneofCase resourceCase_ = ResourceOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ResourceOneofCase ResourceCase {
      get { return resourceCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearResource() {
      resourceCase_ = ResourceOneofCase.None;
      resource_ = null;
    }

    private object checkRequestType_;
    /// <summary>Enum of possible cases for the "check_request_type" oneof.</summary>
    public enum CheckRequestTypeOneofCase {
      None = 0,
      HttpCheck = 5,
      TcpCheck = 6,
    }
    private CheckRequestTypeOneofCase checkRequestTypeCase_ = CheckRequestTypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CheckRequestTypeOneofCase CheckRequestTypeCase {
      get { return checkRequestTypeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCheckRequestType() {
      checkRequestTypeCase_ = CheckRequestTypeOneofCase.None;
      checkRequestType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UptimeCheckConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UptimeCheckConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (DisplayName != other.DisplayName) return false;
      if (!object.Equals(MonitoredResource, other.MonitoredResource)) return false;
      if (!object.Equals(ResourceGroup, other.ResourceGroup)) return false;
      if (!object.Equals(HttpCheck, other.HttpCheck)) return false;
      if (!object.Equals(TcpCheck, other.TcpCheck)) return false;
      if (!object.Equals(Period, other.Period)) return false;
      if (!object.Equals(Timeout, other.Timeout)) return false;
      if(!contentMatchers_.Equals(other.contentMatchers_)) return false;
      if(!selectedRegions_.Equals(other.selectedRegions_)) return false;
      if (ResourceCase != other.ResourceCase) return false;
      if (CheckRequestTypeCase != other.CheckRequestTypeCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (DisplayName.Length != 0) hash ^= DisplayName.GetHashCode();
      if (resourceCase_ == ResourceOneofCase.MonitoredResource) hash ^= MonitoredResource.GetHashCode();
      if (resourceCase_ == ResourceOneofCase.ResourceGroup) hash ^= ResourceGroup.GetHashCode();
      if (checkRequestTypeCase_ == CheckRequestTypeOneofCase.HttpCheck) hash ^= HttpCheck.GetHashCode();
      if (checkRequestTypeCase_ == CheckRequestTypeOneofCase.TcpCheck) hash ^= TcpCheck.GetHashCode();
      if (period_ != null) hash ^= Period.GetHashCode();
      if (timeout_ != null) hash ^= Timeout.GetHashCode();
      hash ^= contentMatchers_.GetHashCode();
      hash ^= selectedRegions_.GetHashCode();
      hash ^= (int) resourceCase_;
      hash ^= (int) checkRequestTypeCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (DisplayName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(DisplayName);
      }
      if (resourceCase_ == ResourceOneofCase.MonitoredResource) {
        output.WriteRawTag(26);
        output.WriteMessage(MonitoredResource);
      }
      if (resourceCase_ == ResourceOneofCase.ResourceGroup) {
        output.WriteRawTag(34);
        output.WriteMessage(ResourceGroup);
      }
      if (checkRequestTypeCase_ == CheckRequestTypeOneofCase.HttpCheck) {
        output.WriteRawTag(42);
        output.WriteMessage(HttpCheck);
      }
      if (checkRequestTypeCase_ == CheckRequestTypeOneofCase.TcpCheck) {
        output.WriteRawTag(50);
        output.WriteMessage(TcpCheck);
      }
      if (period_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Period);
      }
      if (timeout_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Timeout);
      }
      contentMatchers_.WriteTo(output, _repeated_contentMatchers_codec);
      selectedRegions_.WriteTo(output, _repeated_selectedRegions_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (DisplayName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DisplayName);
      }
      if (resourceCase_ == ResourceOneofCase.MonitoredResource) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MonitoredResource);
      }
      if (resourceCase_ == ResourceOneofCase.ResourceGroup) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ResourceGroup);
      }
      if (checkRequestTypeCase_ == CheckRequestTypeOneofCase.HttpCheck) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HttpCheck);
      }
      if (checkRequestTypeCase_ == CheckRequestTypeOneofCase.TcpCheck) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TcpCheck);
      }
      if (period_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Period);
      }
      if (timeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timeout);
      }
      size += contentMatchers_.CalculateSize(_repeated_contentMatchers_codec);
      size += selectedRegions_.CalculateSize(_repeated_selectedRegions_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UptimeCheckConfig other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.DisplayName.Length != 0) {
        DisplayName = other.DisplayName;
      }
      if (other.period_ != null) {
        if (period_ == null) {
          period_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Period.MergeFrom(other.Period);
      }
      if (other.timeout_ != null) {
        if (timeout_ == null) {
          timeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Timeout.MergeFrom(other.Timeout);
      }
      contentMatchers_.Add(other.contentMatchers_);
      selectedRegions_.Add(other.selectedRegions_);
      switch (other.ResourceCase) {
        case ResourceOneofCase.MonitoredResource:
          MonitoredResource = other.MonitoredResource;
          break;
        case ResourceOneofCase.ResourceGroup:
          ResourceGroup = other.ResourceGroup;
          break;
      }

      switch (other.CheckRequestTypeCase) {
        case CheckRequestTypeOneofCase.HttpCheck:
          HttpCheck = other.HttpCheck;
          break;
        case CheckRequestTypeOneofCase.TcpCheck:
          TcpCheck = other.TcpCheck;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            DisplayName = input.ReadString();
            break;
          }
          case 26: {
            global::Google.Api.MonitoredResource subBuilder = new global::Google.Api.MonitoredResource();
            if (resourceCase_ == ResourceOneofCase.MonitoredResource) {
              subBuilder.MergeFrom(MonitoredResource);
            }
            input.ReadMessage(subBuilder);
            MonitoredResource = subBuilder;
            break;
          }
          case 34: {
            global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ResourceGroup subBuilder = new global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ResourceGroup();
            if (resourceCase_ == ResourceOneofCase.ResourceGroup) {
              subBuilder.MergeFrom(ResourceGroup);
            }
            input.ReadMessage(subBuilder);
            ResourceGroup = subBuilder;
            break;
          }
          case 42: {
            global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck subBuilder = new global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck();
            if (checkRequestTypeCase_ == CheckRequestTypeOneofCase.HttpCheck) {
              subBuilder.MergeFrom(HttpCheck);
            }
            input.ReadMessage(subBuilder);
            HttpCheck = subBuilder;
            break;
          }
          case 50: {
            global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.TcpCheck subBuilder = new global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.TcpCheck();
            if (checkRequestTypeCase_ == CheckRequestTypeOneofCase.TcpCheck) {
              subBuilder.MergeFrom(TcpCheck);
            }
            input.ReadMessage(subBuilder);
            TcpCheck = subBuilder;
            break;
          }
          case 58: {
            if (period_ == null) {
              period_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(period_);
            break;
          }
          case 66: {
            if (timeout_ == null) {
              timeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(timeout_);
            break;
          }
          case 74: {
            contentMatchers_.AddEntriesFrom(input, _repeated_contentMatchers_codec);
            break;
          }
          case 82:
          case 80: {
            selectedRegions_.AddEntriesFrom(input, _repeated_selectedRegions_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the UptimeCheckConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// The resource submessage for group checks. It can be used instead of a
      /// monitored resource, when multiple resources are being monitored.
      /// </summary>
      public sealed partial class ResourceGroup : pb::IMessage<ResourceGroup> {
        private static readonly pb::MessageParser<ResourceGroup> _parser = new pb::MessageParser<ResourceGroup>(() => new ResourceGroup());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ResourceGroup> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ResourceGroup() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ResourceGroup(ResourceGroup other) : this() {
          groupId_ = other.groupId_;
          resourceType_ = other.resourceType_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ResourceGroup Clone() {
          return new ResourceGroup(this);
        }

        /// <summary>Field number for the "group_id" field.</summary>
        public const int GroupIdFieldNumber = 1;
        private string groupId_ = "";
        /// <summary>
        /// The group of resources being monitored. Should be only the
        /// group_id, not projects/&lt;project_id>/groups/&lt;group_id>.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string GroupId {
          get { return groupId_; }
          set {
            groupId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "resource_type" field.</summary>
        public const int ResourceTypeFieldNumber = 2;
        private global::Google.Cloud.Monitoring.V3.GroupResourceType resourceType_ = 0;
        /// <summary>
        /// The resource type of the group members.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Monitoring.V3.GroupResourceType ResourceType {
          get { return resourceType_; }
          set {
            resourceType_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as ResourceGroup);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ResourceGroup other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (GroupId != other.GroupId) return false;
          if (ResourceType != other.ResourceType) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (GroupId.Length != 0) hash ^= GroupId.GetHashCode();
          if (ResourceType != 0) hash ^= ResourceType.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (GroupId.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(GroupId);
          }
          if (ResourceType != 0) {
            output.WriteRawTag(16);
            output.WriteEnum((int) ResourceType);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (GroupId.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(GroupId);
          }
          if (ResourceType != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ResourceType);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ResourceGroup other) {
          if (other == null) {
            return;
          }
          if (other.GroupId.Length != 0) {
            GroupId = other.GroupId;
          }
          if (other.ResourceType != 0) {
            ResourceType = other.ResourceType;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                GroupId = input.ReadString();
                break;
              }
              case 16: {
                resourceType_ = (global::Google.Cloud.Monitoring.V3.GroupResourceType) input.ReadEnum();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Information involved in an HTTP/HTTPS uptime check request.
      /// </summary>
      public sealed partial class HttpCheck : pb::IMessage<HttpCheck> {
        private static readonly pb::MessageParser<HttpCheck> _parser = new pb::MessageParser<HttpCheck>(() => new HttpCheck());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<HttpCheck> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HttpCheck() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HttpCheck(HttpCheck other) : this() {
          useSsl_ = other.useSsl_;
          path_ = other.path_;
          port_ = other.port_;
          AuthInfo = other.authInfo_ != null ? other.AuthInfo.Clone() : null;
          maskHeaders_ = other.maskHeaders_;
          headers_ = other.headers_.Clone();
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HttpCheck Clone() {
          return new HttpCheck(this);
        }

        /// <summary>Field number for the "use_ssl" field.</summary>
        public const int UseSslFieldNumber = 1;
        private bool useSsl_;
        /// <summary>
        /// If true, use HTTPS instead of HTTP to run the check.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool UseSsl {
          get { return useSsl_; }
          set {
            useSsl_ = value;
          }
        }

        /// <summary>Field number for the "path" field.</summary>
        public const int PathFieldNumber = 2;
        private string path_ = "";
        /// <summary>
        /// The path to the page to run the check against. Will be combined with the
        /// host (specified within the MonitoredResource) and port to construct the
        /// full URL. Optional (defaults to "/").
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Path {
          get { return path_; }
          set {
            path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "port" field.</summary>
        public const int PortFieldNumber = 3;
        private int port_;
        /// <summary>
        /// The port to the page to run the check against. Will be combined with host
        /// (specified within the MonitoredResource) and path to construct the full
        /// URL. Optional (defaults to 80 without SSL, or 443 with SSL).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int Port {
          get { return port_; }
          set {
            port_ = value;
          }
        }

        /// <summary>Field number for the "auth_info" field.</summary>
        public const int AuthInfoFieldNumber = 4;
        private global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck.Types.BasicAuthentication authInfo_;
        /// <summary>
        /// The authentication information. Optional when creating an HTTP check;
        /// defaults to empty.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck.Types.BasicAuthentication AuthInfo {
          get { return authInfo_; }
          set {
            authInfo_ = value;
          }
        }

        /// <summary>Field number for the "mask_headers" field.</summary>
        public const int MaskHeadersFieldNumber = 5;
        private bool maskHeaders_;
        /// <summary>
        /// Boolean specifiying whether to encrypt the header information.
        /// Encryption should be specified for any headers related to authentication
        /// that you do not wish to be seen when retrieving the configuration. The
        /// server will be responsible for encrypting the headers.
        /// On Get/List calls, if mask_headers is set to True then the headers
        /// will be obscured with ******.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool MaskHeaders {
          get { return maskHeaders_; }
          set {
            maskHeaders_ = value;
          }
        }

        /// <summary>Field number for the "headers" field.</summary>
        public const int HeadersFieldNumber = 6;
        private static readonly pbc::MapField<string, string>.Codec _map_headers_codec
            = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 50);
        private readonly pbc::MapField<string, string> headers_ = new pbc::MapField<string, string>();
        /// <summary>
        /// The list of headers to send as part of the uptime check request.
        /// If two headers have the same key and different values, they should
        /// be entered as a single header, with the value being a comma-separated
        /// list of all the desired values as described at
        /// https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31).
        /// Entering two separate headers with the same key in a Create call will
        /// cause the first to be overwritten by the second.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, string> Headers {
          get { return headers_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as HttpCheck);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(HttpCheck other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (UseSsl != other.UseSsl) return false;
          if (Path != other.Path) return false;
          if (Port != other.Port) return false;
          if (!object.Equals(AuthInfo, other.AuthInfo)) return false;
          if (MaskHeaders != other.MaskHeaders) return false;
          if (!Headers.Equals(other.Headers)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (UseSsl != false) hash ^= UseSsl.GetHashCode();
          if (Path.Length != 0) hash ^= Path.GetHashCode();
          if (Port != 0) hash ^= Port.GetHashCode();
          if (authInfo_ != null) hash ^= AuthInfo.GetHashCode();
          if (MaskHeaders != false) hash ^= MaskHeaders.GetHashCode();
          hash ^= Headers.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (UseSsl != false) {
            output.WriteRawTag(8);
            output.WriteBool(UseSsl);
          }
          if (Path.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Path);
          }
          if (Port != 0) {
            output.WriteRawTag(24);
            output.WriteInt32(Port);
          }
          if (authInfo_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(AuthInfo);
          }
          if (MaskHeaders != false) {
            output.WriteRawTag(40);
            output.WriteBool(MaskHeaders);
          }
          headers_.WriteTo(output, _map_headers_codec);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (UseSsl != false) {
            size += 1 + 1;
          }
          if (Path.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
          }
          if (Port != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Port);
          }
          if (authInfo_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(AuthInfo);
          }
          if (MaskHeaders != false) {
            size += 1 + 1;
          }
          size += headers_.CalculateSize(_map_headers_codec);
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(HttpCheck other) {
          if (other == null) {
            return;
          }
          if (other.UseSsl != false) {
            UseSsl = other.UseSsl;
          }
          if (other.Path.Length != 0) {
            Path = other.Path;
          }
          if (other.Port != 0) {
            Port = other.Port;
          }
          if (other.authInfo_ != null) {
            if (authInfo_ == null) {
              authInfo_ = new global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck.Types.BasicAuthentication();
            }
            AuthInfo.MergeFrom(other.AuthInfo);
          }
          if (other.MaskHeaders != false) {
            MaskHeaders = other.MaskHeaders;
          }
          headers_.Add(other.headers_);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                UseSsl = input.ReadBool();
                break;
              }
              case 18: {
                Path = input.ReadString();
                break;
              }
              case 24: {
                Port = input.ReadInt32();
                break;
              }
              case 34: {
                if (authInfo_ == null) {
                  authInfo_ = new global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck.Types.BasicAuthentication();
                }
                input.ReadMessage(authInfo_);
                break;
              }
              case 40: {
                MaskHeaders = input.ReadBool();
                break;
              }
              case 50: {
                headers_.AddEntriesFrom(input, _map_headers_codec);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the HttpCheck message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// A type of authentication to perform against the specified resource or URL
          /// that uses username and password.
          /// Currently, only Basic authentication is supported in Uptime Monitoring.
          /// </summary>
          public sealed partial class BasicAuthentication : pb::IMessage<BasicAuthentication> {
            private static readonly pb::MessageParser<BasicAuthentication> _parser = new pb::MessageParser<BasicAuthentication>(() => new BasicAuthentication());
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<BasicAuthentication> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public BasicAuthentication() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public BasicAuthentication(BasicAuthentication other) : this() {
              username_ = other.username_;
              password_ = other.password_;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public BasicAuthentication Clone() {
              return new BasicAuthentication(this);
            }

            /// <summary>Field number for the "username" field.</summary>
            public const int UsernameFieldNumber = 1;
            private string username_ = "";
            /// <summary>
            /// The username to authenticate.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string Username {
              get { return username_; }
              set {
                username_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "password" field.</summary>
            public const int PasswordFieldNumber = 2;
            private string password_ = "";
            /// <summary>
            /// The password to authenticate.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string Password {
              get { return password_; }
              set {
                password_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as BasicAuthentication);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(BasicAuthentication other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Username != other.Username) return false;
              if (Password != other.Password) return false;
              return true;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (Username.Length != 0) hash ^= Username.GetHashCode();
              if (Password.Length != 0) hash ^= Password.GetHashCode();
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (Username.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Username);
              }
              if (Password.Length != 0) {
                output.WriteRawTag(18);
                output.WriteString(Password);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (Username.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Username);
              }
              if (Password.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Password);
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(BasicAuthentication other) {
              if (other == null) {
                return;
              }
              if (other.Username.Length != 0) {
                Username = other.Username;
              }
              if (other.Password.Length != 0) {
                Password = other.Password;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    input.SkipLastField();
                    break;
                  case 10: {
                    Username = input.ReadString();
                    break;
                  }
                  case 18: {
                    Password = input.ReadString();
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

      /// <summary>
      /// Information required for a TCP uptime check request.
      /// </summary>
      public sealed partial class TcpCheck : pb::IMessage<TcpCheck> {
        private static readonly pb::MessageParser<TcpCheck> _parser = new pb::MessageParser<TcpCheck>(() => new TcpCheck());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TcpCheck> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TcpCheck() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TcpCheck(TcpCheck other) : this() {
          port_ = other.port_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TcpCheck Clone() {
          return new TcpCheck(this);
        }

        /// <summary>Field number for the "port" field.</summary>
        public const int PortFieldNumber = 1;
        private int port_;
        /// <summary>
        /// The port to the page to run the check against. Will be combined with host
        /// (specified within the MonitoredResource) to construct the full URL.
        /// Required.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int Port {
          get { return port_; }
          set {
            port_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as TcpCheck);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TcpCheck other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Port != other.Port) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Port != 0) hash ^= Port.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Port != 0) {
            output.WriteRawTag(8);
            output.WriteInt32(Port);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Port != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Port);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TcpCheck other) {
          if (other == null) {
            return;
          }
          if (other.Port != 0) {
            Port = other.Port;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                Port = input.ReadInt32();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Used to perform string matching. Currently, this matches on the exact
      /// content. In the future, it can be expanded to allow for regular expressions
      /// and more complex matching.
      /// </summary>
      public sealed partial class ContentMatcher : pb::IMessage<ContentMatcher> {
        private static readonly pb::MessageParser<ContentMatcher> _parser = new pb::MessageParser<ContentMatcher>(() => new ContentMatcher());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ContentMatcher> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ContentMatcher() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ContentMatcher(ContentMatcher other) : this() {
          content_ = other.content_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ContentMatcher Clone() {
          return new ContentMatcher(this);
        }

        /// <summary>Field number for the "content" field.</summary>
        public const int ContentFieldNumber = 1;
        private string content_ = "";
        /// <summary>
        /// String content to match
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Content {
          get { return content_; }
          set {
            content_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as ContentMatcher);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ContentMatcher other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Content != other.Content) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Content.Length != 0) hash ^= Content.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Content.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Content);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Content.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Content);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ContentMatcher other) {
          if (other == null) {
            return;
          }
          if (other.Content.Length != 0) {
            Content = other.Content;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                Content = input.ReadString();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Contains the region, location, and list of IP
  /// addresses where checkers in the location run from.
  /// </summary>
  public sealed partial class UptimeCheckIp : pb::IMessage<UptimeCheckIp> {
    private static readonly pb::MessageParser<UptimeCheckIp> _parser = new pb::MessageParser<UptimeCheckIp>(() => new UptimeCheckIp());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UptimeCheckIp> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Monitoring.V3.UptimeReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UptimeCheckIp() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UptimeCheckIp(UptimeCheckIp other) : this() {
      region_ = other.region_;
      location_ = other.location_;
      ipAddress_ = other.ipAddress_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UptimeCheckIp Clone() {
      return new UptimeCheckIp(this);
    }

    /// <summary>Field number for the "region" field.</summary>
    public const int RegionFieldNumber = 1;
    private global::Google.Cloud.Monitoring.V3.UptimeCheckRegion region_ = 0;
    /// <summary>
    /// A broad region category in which the IP address is located.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.V3.UptimeCheckRegion Region {
      get { return region_; }
      set {
        region_ = value;
      }
    }

    /// <summary>Field number for the "location" field.</summary>
    public const int LocationFieldNumber = 2;
    private string location_ = "";
    /// <summary>
    /// A more specific location within the region that typically encodes
    /// a particular city/town/metro (and its containing state/province or country)
    /// within the broader umbrella region category.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Location {
      get { return location_; }
      set {
        location_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "ip_address" field.</summary>
    public const int IpAddressFieldNumber = 3;
    private string ipAddress_ = "";
    /// <summary>
    /// The IP address from which the uptime check originates. This is a full
    /// IP address (not an IP address range). Most IP addresses, as of this
    /// publication, are in IPv4 format; however, one should not rely on the
    /// IP addresses being in IPv4 format indefinitely and should support
    /// interpreting this field in either IPv4 or IPv6 format.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string IpAddress {
      get { return ipAddress_; }
      set {
        ipAddress_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UptimeCheckIp);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UptimeCheckIp other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Region != other.Region) return false;
      if (Location != other.Location) return false;
      if (IpAddress != other.IpAddress) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Region != 0) hash ^= Region.GetHashCode();
      if (Location.Length != 0) hash ^= Location.GetHashCode();
      if (IpAddress.Length != 0) hash ^= IpAddress.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Region != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Region);
      }
      if (Location.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Location);
      }
      if (IpAddress.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(IpAddress);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Region != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Region);
      }
      if (Location.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Location);
      }
      if (IpAddress.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(IpAddress);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UptimeCheckIp other) {
      if (other == null) {
        return;
      }
      if (other.Region != 0) {
        Region = other.Region;
      }
      if (other.Location.Length != 0) {
        Location = other.Location;
      }
      if (other.IpAddress.Length != 0) {
        IpAddress = other.IpAddress;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            region_ = (global::Google.Cloud.Monitoring.V3.UptimeCheckRegion) input.ReadEnum();
            break;
          }
          case 18: {
            Location = input.ReadString();
            break;
          }
          case 26: {
            IpAddress = input.ReadString();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
