// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/monitoring/v3/common.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.Monitoring.V3 {

  /// <summary>Holder for reflection information generated from google/monitoring/v3/common.proto</summary>
  public static partial class CommonReflection {

    #region Descriptor
    /// <summary>File descriptor for google/monitoring/v3/common.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static CommonReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiFnb29nbGUvbW9uaXRvcmluZy92My9jb21tb24ucHJvdG8SFGdvb2dsZS5t",
            "b25pdG9yaW5nLnYzGhxnb29nbGUvYXBpL2Fubm90YXRpb25zLnByb3RvGh1n",
            "b29nbGUvYXBpL2Rpc3RyaWJ1dGlvbi5wcm90bxoeZ29vZ2xlL3Byb3RvYnVm",
            "L2R1cmF0aW9uLnByb3RvGh9nb29nbGUvcHJvdG9idWYvdGltZXN0YW1wLnBy",
            "b3RvIqoBCgpUeXBlZFZhbHVlEhQKCmJvb2xfdmFsdWUYASABKAhIABIVCgtp",
            "bnQ2NF92YWx1ZRgCIAEoA0gAEhYKDGRvdWJsZV92YWx1ZRgDIAEoAUgAEhYK",
            "DHN0cmluZ192YWx1ZRgEIAEoCUgAEjYKEmRpc3RyaWJ1dGlvbl92YWx1ZRgF",
            "IAEoCzIYLmdvb2dsZS5hcGkuRGlzdHJpYnV0aW9uSABCBwoFdmFsdWUibAoM",
            "VGltZUludGVydmFsEiwKCGVuZF90aW1lGAIgASgLMhouZ29vZ2xlLnByb3Rv",
            "YnVmLlRpbWVzdGFtcBIuCgpzdGFydF90aW1lGAEgASgLMhouZ29vZ2xlLnBy",
            "b3RvYnVmLlRpbWVzdGFtcCKtBwoLQWdncmVnYXRpb24SMwoQYWxpZ25tZW50",
            "X3BlcmlvZBgBIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhJFChJw",
            "ZXJfc2VyaWVzX2FsaWduZXIYAiABKA4yKS5nb29nbGUubW9uaXRvcmluZy52",
            "My5BZ2dyZWdhdGlvbi5BbGlnbmVyEkcKFGNyb3NzX3Nlcmllc19yZWR1Y2Vy",
            "GAQgASgOMikuZ29vZ2xlLm1vbml0b3JpbmcudjMuQWdncmVnYXRpb24uUmVk",
            "dWNlchIXCg9ncm91cF9ieV9maWVsZHMYBSADKAkiiwMKB0FsaWduZXISDgoK",
            "QUxJR05fTk9ORRAAEg8KC0FMSUdOX0RFTFRBEAESDgoKQUxJR05fUkFURRAC",
            "EhUKEUFMSUdOX0lOVEVSUE9MQVRFEAMSFAoQQUxJR05fTkVYVF9PTERFUhAE",
            "Eg0KCUFMSUdOX01JThAKEg0KCUFMSUdOX01BWBALEg4KCkFMSUdOX01FQU4Q",
            "DBIPCgtBTElHTl9DT1VOVBANEg0KCUFMSUdOX1NVTRAOEhAKDEFMSUdOX1NU",
            "RERFVhAPEhQKEEFMSUdOX0NPVU5UX1RSVUUQEBIXChNBTElHTl9GUkFDVElP",
            "Tl9UUlVFEBESFwoTQUxJR05fUEVSQ0VOVElMRV85ORASEhcKE0FMSUdOX1BF",
            "UkNFTlRJTEVfOTUQExIXChNBTElHTl9QRVJDRU5USUxFXzUwEBQSFwoTQUxJ",
            "R05fUEVSQ0VOVElMRV8wNRAVEhgKFEFMSUdOX1BFUkNFTlRfQ0hBTkdFEBcS",
            "FQoRQUxJR05fQ09VTlRfRkFMU0UQGCKxAgoHUmVkdWNlchIPCgtSRURVQ0Vf",
            "Tk9ORRAAEg8KC1JFRFVDRV9NRUFOEAESDgoKUkVEVUNFX01JThACEg4KClJF",
            "RFVDRV9NQVgQAxIOCgpSRURVQ0VfU1VNEAQSEQoNUkVEVUNFX1NURERFVhAF",
            "EhAKDFJFRFVDRV9DT1VOVBAGEhUKEVJFRFVDRV9DT1VOVF9UUlVFEAcSGAoU",
            "UkVEVUNFX0ZSQUNUSU9OX1RSVUUQCBIYChRSRURVQ0VfUEVSQ0VOVElMRV85",
            "ORAJEhgKFFJFRFVDRV9QRVJDRU5USUxFXzk1EAoSGAoUUkVEVUNFX1BFUkNF",
            "TlRJTEVfNTAQCxIYChRSRURVQ0VfUEVSQ0VOVElMRV8wNRAMEhYKElJFRFVD",
            "RV9DT1VOVF9GQUxTRRAPIvYCChRQaWNrVGltZVNlcmllc0ZpbHRlchJJCg5y",
            "YW5raW5nX21ldGhvZBgBIAEoDjIxLmdvb2dsZS5tb25pdG9yaW5nLnYzLlBp",
            "Y2tUaW1lU2VyaWVzRmlsdGVyLk1ldGhvZBIXCg9udW1fdGltZV9zZXJpZXMY",
            "AiABKAUSRwoJZGlyZWN0aW9uGAMgASgOMjQuZ29vZ2xlLm1vbml0b3Jpbmcu",
            "djMuUGlja1RpbWVTZXJpZXNGaWx0ZXIuRGlyZWN0aW9uInQKBk1ldGhvZBIW",
            "ChJNRVRIT0RfVU5TUEVDSUZJRUQQABIPCgtNRVRIT0RfTUVBThABEg4KCk1F",
            "VEhPRF9NQVgQAhIOCgpNRVRIT0RfTUlOEAMSDgoKTUVUSE9EX1NVTRAEEhEK",
            "DU1FVEhPRF9MQVRFU1QQBSI7CglEaXJlY3Rpb24SGQoVRElSRUNUSU9OX1VO",
            "U1BFQ0lGSUVEEAASBwoDVE9QEAESCgoGQk9UVE9NEAIqngEKDkNvbXBhcmlz",
            "b25UeXBlEhoKFkNPTVBBUklTT05fVU5TUEVDSUZJRUQQABIRCg1DT01QQVJJ",
            "U09OX0dUEAESEQoNQ09NUEFSSVNPTl9HRRACEhEKDUNPTVBBUklTT05fTFQQ",
            "AxIRCg1DT01QQVJJU09OX0xFEAQSEQoNQ09NUEFSSVNPTl9FURAFEhEKDUNP",
            "TVBBUklTT05fTkUQBipdCgtTZXJ2aWNlVGllchIcChhTRVJWSUNFX1RJRVJf",
            "VU5TUEVDSUZJRUQQABIWChJTRVJWSUNFX1RJRVJfQkFTSUMQARIYChRTRVJW",
            "SUNFX1RJRVJfUFJFTUlVTRACQqMBChhjb20uZ29vZ2xlLm1vbml0b3Jpbmcu",
            "djNCC0NvbW1vblByb3RvUAFaPmdvb2dsZS5nb2xhbmcub3JnL2dlbnByb3Rv",
            "L2dvb2dsZWFwaXMvbW9uaXRvcmluZy92Mzttb25pdG9yaW5nqgIaR29vZ2xl",
            "LkNsb3VkLk1vbml0b3JpbmcuVjPKAhpHb29nbGVcQ2xvdWRcTW9uaXRvcmlu",
            "Z1xWM2IGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Api.DistributionReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Google.Cloud.Monitoring.V3.ComparisonType), typeof(global::Google.Cloud.Monitoring.V3.ServiceTier), }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.TypedValue), global::Google.Cloud.Monitoring.V3.TypedValue.Parser, new[]{ "BoolValue", "Int64Value", "DoubleValue", "StringValue", "DistributionValue" }, new[]{ "Value" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.TimeInterval), global::Google.Cloud.Monitoring.V3.TimeInterval.Parser, new[]{ "EndTime", "StartTime" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.Aggregation), global::Google.Cloud.Monitoring.V3.Aggregation.Parser, new[]{ "AlignmentPeriod", "PerSeriesAligner", "CrossSeriesReducer", "GroupByFields" }, null, new[]{ typeof(global::Google.Cloud.Monitoring.V3.Aggregation.Types.Aligner), typeof(global::Google.Cloud.Monitoring.V3.Aggregation.Types.Reducer) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.PickTimeSeriesFilter), global::Google.Cloud.Monitoring.V3.PickTimeSeriesFilter.Parser, new[]{ "RankingMethod", "NumTimeSeries", "Direction" }, null, new[]{ typeof(global::Google.Cloud.Monitoring.V3.PickTimeSeriesFilter.Types.Method), typeof(global::Google.Cloud.Monitoring.V3.PickTimeSeriesFilter.Types.Direction) }, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// Specifies an ordering relationship on two arguments, here called left and
  /// right.
  /// </summary>
  public enum ComparisonType {
    /// <summary>
    /// No ordering relationship is specified.
    /// </summary>
    [pbr::OriginalName("COMPARISON_UNSPECIFIED")] ComparisonUnspecified = 0,
    /// <summary>
    /// The left argument is greater than the right argument.
    /// </summary>
    [pbr::OriginalName("COMPARISON_GT")] ComparisonGt = 1,
    /// <summary>
    /// The left argument is greater than or equal to the right argument.
    /// </summary>
    [pbr::OriginalName("COMPARISON_GE")] ComparisonGe = 2,
    /// <summary>
    /// The left argument is less than the right argument.
    /// </summary>
    [pbr::OriginalName("COMPARISON_LT")] ComparisonLt = 3,
    /// <summary>
    /// The left argument is less than or equal to the right argument.
    /// </summary>
    [pbr::OriginalName("COMPARISON_LE")] ComparisonLe = 4,
    /// <summary>
    /// The left argument is equal to the right argument.
    /// </summary>
    [pbr::OriginalName("COMPARISON_EQ")] ComparisonEq = 5,
    /// <summary>
    /// The left argument is not equal to the right argument.
    /// </summary>
    [pbr::OriginalName("COMPARISON_NE")] ComparisonNe = 6,
  }

  /// <summary>
  /// The tier of service for a Stackdriver account. Please see the
  /// [service tiers documentation](https://cloud.google.com/monitoring/accounts/tiers)
  /// for more details.
  /// </summary>
  public enum ServiceTier {
    /// <summary>
    /// An invalid sentinel value, used to indicate that a tier has not
    /// been provided explicitly.
    /// </summary>
    [pbr::OriginalName("SERVICE_TIER_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// The Stackdriver Basic tier, a free tier of service that provides basic
    /// features, a moderate allotment of logs, and access to built-in metrics.
    /// A number of features are not available in this tier. For more details,
    /// see [the service tiers documentation](https://cloud.google.com/monitoring/accounts/tiers).
    /// </summary>
    [pbr::OriginalName("SERVICE_TIER_BASIC")] Basic = 1,
    /// <summary>
    /// The Stackdriver Premium tier, a higher, more expensive tier of service
    /// that provides access to all Stackdriver features, lets you use Stackdriver
    /// with AWS accounts, and has a larger allotments for logs and metrics. For
    /// more details, see [the service tiers documentation](https://cloud.google.com/monitoring/accounts/tiers).
    /// </summary>
    [pbr::OriginalName("SERVICE_TIER_PREMIUM")] Premium = 2,
  }

  #endregion

  #region Messages
  /// <summary>
  /// A single strongly-typed value.
  /// </summary>
  public sealed partial class TypedValue : pb::IMessage<TypedValue> {
    private static readonly pb::MessageParser<TypedValue> _parser = new pb::MessageParser<TypedValue>(() => new TypedValue());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TypedValue> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Monitoring.V3.CommonReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TypedValue() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TypedValue(TypedValue other) : this() {
      switch (other.ValueCase) {
        case ValueOneofCase.BoolValue:
          BoolValue = other.BoolValue;
          break;
        case ValueOneofCase.Int64Value:
          Int64Value = other.Int64Value;
          break;
        case ValueOneofCase.DoubleValue:
          DoubleValue = other.DoubleValue;
          break;
        case ValueOneofCase.StringValue:
          StringValue = other.StringValue;
          break;
        case ValueOneofCase.DistributionValue:
          DistributionValue = other.DistributionValue.Clone();
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TypedValue Clone() {
      return new TypedValue(this);
    }

    /// <summary>Field number for the "bool_value" field.</summary>
    public const int BoolValueFieldNumber = 1;
    /// <summary>
    /// A Boolean value: `true` or `false`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool BoolValue {
      get { return valueCase_ == ValueOneofCase.BoolValue ? (bool) value_ : false; }
      set {
        value_ = value;
        valueCase_ = ValueOneofCase.BoolValue;
      }
    }

    /// <summary>Field number for the "int64_value" field.</summary>
    public const int Int64ValueFieldNumber = 2;
    /// <summary>
    /// A 64-bit integer. Its range is approximately &amp;plusmn;9.2x10&lt;sup>18&lt;/sup>.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Int64Value {
      get { return valueCase_ == ValueOneofCase.Int64Value ? (long) value_ : 0L; }
      set {
        value_ = value;
        valueCase_ = ValueOneofCase.Int64Value;
      }
    }

    /// <summary>Field number for the "double_value" field.</summary>
    public const int DoubleValueFieldNumber = 3;
    /// <summary>
    /// A 64-bit double-precision floating-point number. Its magnitude
    /// is approximately &amp;plusmn;10&lt;sup>&amp;plusmn;300&lt;/sup> and it has 16
    /// significant digits of precision.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double DoubleValue {
      get { return valueCase_ == ValueOneofCase.DoubleValue ? (double) value_ : 0D; }
      set {
        value_ = value;
        valueCase_ = ValueOneofCase.DoubleValue;
      }
    }

    /// <summary>Field number for the "string_value" field.</summary>
    public const int StringValueFieldNumber = 4;
    /// <summary>
    /// A variable-length string value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StringValue {
      get { return valueCase_ == ValueOneofCase.StringValue ? (string) value_ : ""; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        valueCase_ = ValueOneofCase.StringValue;
      }
    }

    /// <summary>Field number for the "distribution_value" field.</summary>
    public const int DistributionValueFieldNumber = 5;
    /// <summary>
    /// A distribution value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Api.Distribution DistributionValue {
      get { return valueCase_ == ValueOneofCase.DistributionValue ? (global::Google.Api.Distribution) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.DistributionValue;
      }
    }

    private object value_;
    /// <summary>Enum of possible cases for the "value" oneof.</summary>
    public enum ValueOneofCase {
      None = 0,
      BoolValue = 1,
      Int64Value = 2,
      DoubleValue = 3,
      StringValue = 4,
      DistributionValue = 5,
    }
    private ValueOneofCase valueCase_ = ValueOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueOneofCase ValueCase {
      get { return valueCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearValue() {
      valueCase_ = ValueOneofCase.None;
      value_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TypedValue);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TypedValue other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BoolValue != other.BoolValue) return false;
      if (Int64Value != other.Int64Value) return false;
      if (DoubleValue != other.DoubleValue) return false;
      if (StringValue != other.StringValue) return false;
      if (!object.Equals(DistributionValue, other.DistributionValue)) return false;
      if (ValueCase != other.ValueCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (valueCase_ == ValueOneofCase.BoolValue) hash ^= BoolValue.GetHashCode();
      if (valueCase_ == ValueOneofCase.Int64Value) hash ^= Int64Value.GetHashCode();
      if (valueCase_ == ValueOneofCase.DoubleValue) hash ^= DoubleValue.GetHashCode();
      if (valueCase_ == ValueOneofCase.StringValue) hash ^= StringValue.GetHashCode();
      if (valueCase_ == ValueOneofCase.DistributionValue) hash ^= DistributionValue.GetHashCode();
      hash ^= (int) valueCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (valueCase_ == ValueOneofCase.BoolValue) {
        output.WriteRawTag(8);
        output.WriteBool(BoolValue);
      }
      if (valueCase_ == ValueOneofCase.Int64Value) {
        output.WriteRawTag(16);
        output.WriteInt64(Int64Value);
      }
      if (valueCase_ == ValueOneofCase.DoubleValue) {
        output.WriteRawTag(25);
        output.WriteDouble(DoubleValue);
      }
      if (valueCase_ == ValueOneofCase.StringValue) {
        output.WriteRawTag(34);
        output.WriteString(StringValue);
      }
      if (valueCase_ == ValueOneofCase.DistributionValue) {
        output.WriteRawTag(42);
        output.WriteMessage(DistributionValue);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (valueCase_ == ValueOneofCase.BoolValue) {
        size += 1 + 1;
      }
      if (valueCase_ == ValueOneofCase.Int64Value) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Int64Value);
      }
      if (valueCase_ == ValueOneofCase.DoubleValue) {
        size += 1 + 8;
      }
      if (valueCase_ == ValueOneofCase.StringValue) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StringValue);
      }
      if (valueCase_ == ValueOneofCase.DistributionValue) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DistributionValue);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TypedValue other) {
      if (other == null) {
        return;
      }
      switch (other.ValueCase) {
        case ValueOneofCase.BoolValue:
          BoolValue = other.BoolValue;
          break;
        case ValueOneofCase.Int64Value:
          Int64Value = other.Int64Value;
          break;
        case ValueOneofCase.DoubleValue:
          DoubleValue = other.DoubleValue;
          break;
        case ValueOneofCase.StringValue:
          StringValue = other.StringValue;
          break;
        case ValueOneofCase.DistributionValue:
          DistributionValue = other.DistributionValue;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            BoolValue = input.ReadBool();
            break;
          }
          case 16: {
            Int64Value = input.ReadInt64();
            break;
          }
          case 25: {
            DoubleValue = input.ReadDouble();
            break;
          }
          case 34: {
            StringValue = input.ReadString();
            break;
          }
          case 42: {
            global::Google.Api.Distribution subBuilder = new global::Google.Api.Distribution();
            if (valueCase_ == ValueOneofCase.DistributionValue) {
              subBuilder.MergeFrom(DistributionValue);
            }
            input.ReadMessage(subBuilder);
            DistributionValue = subBuilder;
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A time interval extending just after a start time through an end time.
  /// If the start time is the same as the end time, then the interval
  /// represents a single point in time.
  /// </summary>
  public sealed partial class TimeInterval : pb::IMessage<TimeInterval> {
    private static readonly pb::MessageParser<TimeInterval> _parser = new pb::MessageParser<TimeInterval>(() => new TimeInterval());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TimeInterval> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Monitoring.V3.CommonReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimeInterval() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimeInterval(TimeInterval other) : this() {
      EndTime = other.endTime_ != null ? other.EndTime.Clone() : null;
      StartTime = other.startTime_ != null ? other.StartTime.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimeInterval Clone() {
      return new TimeInterval(this);
    }

    /// <summary>Field number for the "end_time" field.</summary>
    public const int EndTimeFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Timestamp endTime_;
    /// <summary>
    /// Required. The end of the time interval.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp EndTime {
      get { return endTime_; }
      set {
        endTime_ = value;
      }
    }

    /// <summary>Field number for the "start_time" field.</summary>
    public const int StartTimeFieldNumber = 1;
    private global::Google.Protobuf.WellKnownTypes.Timestamp startTime_;
    /// <summary>
    /// Optional. The beginning of the time interval.  The default value
    /// for the start time is the end time. The start time must not be
    /// later than the end time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp StartTime {
      get { return startTime_; }
      set {
        startTime_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TimeInterval);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TimeInterval other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(EndTime, other.EndTime)) return false;
      if (!object.Equals(StartTime, other.StartTime)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (endTime_ != null) hash ^= EndTime.GetHashCode();
      if (startTime_ != null) hash ^= StartTime.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (startTime_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(StartTime);
      }
      if (endTime_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(EndTime);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (endTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EndTime);
      }
      if (startTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartTime);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TimeInterval other) {
      if (other == null) {
        return;
      }
      if (other.endTime_ != null) {
        if (endTime_ == null) {
          endTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        EndTime.MergeFrom(other.EndTime);
      }
      if (other.startTime_ != null) {
        if (startTime_ == null) {
          startTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        StartTime.MergeFrom(other.StartTime);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (startTime_ == null) {
              startTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(startTime_);
            break;
          }
          case 18: {
            if (endTime_ == null) {
              endTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(endTime_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Describes how to combine multiple time series to provide different views of
  /// the data.  Aggregation consists of an alignment step on individual time
  /// series (`alignment_period` and `per_series_aligner`) followed by an optional
  /// reduction step of the data across the aligned time series
  /// (`cross_series_reducer` and `group_by_fields).  For more details, see
  /// [Aggregation](/monitoring/api/learn_more#aggregation).
  /// </summary>
  public sealed partial class Aggregation : pb::IMessage<Aggregation> {
    private static readonly pb::MessageParser<Aggregation> _parser = new pb::MessageParser<Aggregation>(() => new Aggregation());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Aggregation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Monitoring.V3.CommonReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Aggregation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Aggregation(Aggregation other) : this() {
      AlignmentPeriod = other.alignmentPeriod_ != null ? other.AlignmentPeriod.Clone() : null;
      perSeriesAligner_ = other.perSeriesAligner_;
      crossSeriesReducer_ = other.crossSeriesReducer_;
      groupByFields_ = other.groupByFields_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Aggregation Clone() {
      return new Aggregation(this);
    }

    /// <summary>Field number for the "alignment_period" field.</summary>
    public const int AlignmentPeriodFieldNumber = 1;
    private global::Google.Protobuf.WellKnownTypes.Duration alignmentPeriod_;
    /// <summary>
    /// The alignment period for per-[time series][google.monitoring.v3.TimeSeries]
    /// alignment. If present, `alignmentPeriod` must be at least 60
    /// seconds.  After per-time series alignment, each time series will
    /// contain data points only on the period boundaries. If
    /// `perSeriesAligner` is not specified or equals `ALIGN_NONE`, then
    /// this field is ignored. If `perSeriesAligner` is specified and
    /// does not equal `ALIGN_NONE`, then this field must be defined;
    /// otherwise an error is returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration AlignmentPeriod {
      get { return alignmentPeriod_; }
      set {
        alignmentPeriod_ = value;
      }
    }

    /// <summary>Field number for the "per_series_aligner" field.</summary>
    public const int PerSeriesAlignerFieldNumber = 2;
    private global::Google.Cloud.Monitoring.V3.Aggregation.Types.Aligner perSeriesAligner_ = 0;
    /// <summary>
    /// The approach to be used to align individual time series. Not all
    /// alignment functions may be applied to all time series, depending
    /// on the metric type and value type of the original time
    /// series. Alignment may change the metric type or the value type of
    /// the time series.
    ///
    /// Time series data must be aligned in order to perform cross-time
    /// series reduction. If `crossSeriesReducer` is specified, then
    /// `perSeriesAligner` must be specified and not equal `ALIGN_NONE`
    /// and `alignmentPeriod` must be specified; otherwise, an error is
    /// returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.V3.Aggregation.Types.Aligner PerSeriesAligner {
      get { return perSeriesAligner_; }
      set {
        perSeriesAligner_ = value;
      }
    }

    /// <summary>Field number for the "cross_series_reducer" field.</summary>
    public const int CrossSeriesReducerFieldNumber = 4;
    private global::Google.Cloud.Monitoring.V3.Aggregation.Types.Reducer crossSeriesReducer_ = 0;
    /// <summary>
    /// The approach to be used to combine time series. Not all reducer
    /// functions may be applied to all time series, depending on the
    /// metric type and the value type of the original time
    /// series. Reduction may change the metric type of value type of the
    /// time series.
    ///
    /// Time series data must be aligned in order to perform cross-time
    /// series reduction. If `crossSeriesReducer` is specified, then
    /// `perSeriesAligner` must be specified and not equal `ALIGN_NONE`
    /// and `alignmentPeriod` must be specified; otherwise, an error is
    /// returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.V3.Aggregation.Types.Reducer CrossSeriesReducer {
      get { return crossSeriesReducer_; }
      set {
        crossSeriesReducer_ = value;
      }
    }

    /// <summary>Field number for the "group_by_fields" field.</summary>
    public const int GroupByFieldsFieldNumber = 5;
    private static readonly pb::FieldCodec<string> _repeated_groupByFields_codec
        = pb::FieldCodec.ForString(42);
    private readonly pbc::RepeatedField<string> groupByFields_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// The set of fields to preserve when `crossSeriesReducer` is
    /// specified. The `groupByFields` determine how the time series are
    /// partitioned into subsets prior to applying the aggregation
    /// function. Each subset contains time series that have the same
    /// value for each of the grouping fields. Each individual time
    /// series is a member of exactly one subset. The
    /// `crossSeriesReducer` is applied to each subset of time series.
    /// It is not possible to reduce across different resource types, so
    /// this field implicitly contains `resource.type`.  Fields not
    /// specified in `groupByFields` are aggregated away.  If
    /// `groupByFields` is not specified and all the time series have
    /// the same resource type, then the time series are aggregated into
    /// a single output time series. If `crossSeriesReducer` is not
    /// defined, this field is ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> GroupByFields {
      get { return groupByFields_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Aggregation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Aggregation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AlignmentPeriod, other.AlignmentPeriod)) return false;
      if (PerSeriesAligner != other.PerSeriesAligner) return false;
      if (CrossSeriesReducer != other.CrossSeriesReducer) return false;
      if(!groupByFields_.Equals(other.groupByFields_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (alignmentPeriod_ != null) hash ^= AlignmentPeriod.GetHashCode();
      if (PerSeriesAligner != 0) hash ^= PerSeriesAligner.GetHashCode();
      if (CrossSeriesReducer != 0) hash ^= CrossSeriesReducer.GetHashCode();
      hash ^= groupByFields_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (alignmentPeriod_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AlignmentPeriod);
      }
      if (PerSeriesAligner != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) PerSeriesAligner);
      }
      if (CrossSeriesReducer != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) CrossSeriesReducer);
      }
      groupByFields_.WriteTo(output, _repeated_groupByFields_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (alignmentPeriod_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AlignmentPeriod);
      }
      if (PerSeriesAligner != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PerSeriesAligner);
      }
      if (CrossSeriesReducer != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CrossSeriesReducer);
      }
      size += groupByFields_.CalculateSize(_repeated_groupByFields_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Aggregation other) {
      if (other == null) {
        return;
      }
      if (other.alignmentPeriod_ != null) {
        if (alignmentPeriod_ == null) {
          alignmentPeriod_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        AlignmentPeriod.MergeFrom(other.AlignmentPeriod);
      }
      if (other.PerSeriesAligner != 0) {
        PerSeriesAligner = other.PerSeriesAligner;
      }
      if (other.CrossSeriesReducer != 0) {
        CrossSeriesReducer = other.CrossSeriesReducer;
      }
      groupByFields_.Add(other.groupByFields_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (alignmentPeriod_ == null) {
              alignmentPeriod_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(alignmentPeriod_);
            break;
          }
          case 16: {
            perSeriesAligner_ = (global::Google.Cloud.Monitoring.V3.Aggregation.Types.Aligner) input.ReadEnum();
            break;
          }
          case 32: {
            crossSeriesReducer_ = (global::Google.Cloud.Monitoring.V3.Aggregation.Types.Reducer) input.ReadEnum();
            break;
          }
          case 42: {
            groupByFields_.AddEntriesFrom(input, _repeated_groupByFields_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Aggregation message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// The Aligner describes how to bring the data points in a single
      /// time series into temporal alignment.
      /// </summary>
      public enum Aligner {
        /// <summary>
        /// No alignment. Raw data is returned. Not valid if cross-time
        /// series reduction is requested. The value type of the result is
        /// the same as the value type of the input.
        /// </summary>
        [pbr::OriginalName("ALIGN_NONE")] AlignNone = 0,
        /// <summary>
        /// Align and convert to delta metric type. This alignment is valid
        /// for cumulative metrics and delta metrics. Aligning an existing
        /// delta metric to a delta metric requires that the alignment
        /// period be increased. The value type of the result is the same
        /// as the value type of the input.
        ///
        /// One can think of this aligner as a rate but without time units; that
        /// is, the output is conceptually (second_point - first_point).
        /// </summary>
        [pbr::OriginalName("ALIGN_DELTA")] AlignDelta = 1,
        /// <summary>
        /// Align and convert to a rate. This alignment is valid for
        /// cumulative metrics and delta metrics with numeric values. The output is a
        /// gauge metric with value type
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
        ///
        /// One can think of this aligner as conceptually providing the slope of
        /// the line that passes through the value at the start and end of the
        /// window. In other words, this is conceptually ((y1 - y0)/(t1 - t0)),
        /// and the output unit is one that has a "/time" dimension.
        /// </summary>
        [pbr::OriginalName("ALIGN_RATE")] AlignRate = 2,
        /// <summary>
        /// Align by interpolating between adjacent points around the
        /// period boundary. This alignment is valid for gauge
        /// metrics with numeric values. The value type of the result is the same
        /// as the value type of the input.
        /// </summary>
        [pbr::OriginalName("ALIGN_INTERPOLATE")] AlignInterpolate = 3,
        /// <summary>
        /// Align by shifting the oldest data point before the period
        /// boundary to the boundary. This alignment is valid for gauge
        /// metrics. The value type of the result is the same as the
        /// value type of the input.
        /// </summary>
        [pbr::OriginalName("ALIGN_NEXT_OLDER")] AlignNextOlder = 4,
        /// <summary>
        /// Align time series via aggregation. The resulting data point in
        /// the alignment period is the minimum of all data points in the
        /// period. This alignment is valid for gauge and delta metrics with numeric
        /// values. The value type of the result is the same as the value
        /// type of the input.
        /// </summary>
        [pbr::OriginalName("ALIGN_MIN")] AlignMin = 10,
        /// <summary>
        /// Align time series via aggregation. The resulting data point in
        /// the alignment period is the maximum of all data points in the
        /// period. This alignment is valid for gauge and delta metrics with numeric
        /// values. The value type of the result is the same as the value
        /// type of the input.
        /// </summary>
        [pbr::OriginalName("ALIGN_MAX")] AlignMax = 11,
        /// <summary>
        /// Align time series via aggregation. The resulting data point in
        /// the alignment period is the average or arithmetic mean of all
        /// data points in the period. This alignment is valid for gauge and delta
        /// metrics with numeric values. The value type of the output is
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
        /// </summary>
        [pbr::OriginalName("ALIGN_MEAN")] AlignMean = 12,
        /// <summary>
        /// Align time series via aggregation. The resulting data point in
        /// the alignment period is the count of all data points in the
        /// period. This alignment is valid for gauge and delta metrics with numeric
        /// or Boolean values. The value type of the output is
        /// [INT64][google.api.MetricDescriptor.ValueType.INT64].
        /// </summary>
        [pbr::OriginalName("ALIGN_COUNT")] AlignCount = 13,
        /// <summary>
        /// Align time series via aggregation. The resulting data point in
        /// the alignment period is the sum of all data points in the
        /// period. This alignment is valid for gauge and delta metrics with numeric
        /// and distribution values. The value type of the output is the
        /// same as the value type of the input.
        /// </summary>
        [pbr::OriginalName("ALIGN_SUM")] AlignSum = 14,
        /// <summary>
        /// Align time series via aggregation. The resulting data point in
        /// the alignment period is the standard deviation of all data
        /// points in the period. This alignment is valid for gauge and delta metrics
        /// with numeric values. The value type of the output is
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
        /// </summary>
        [pbr::OriginalName("ALIGN_STDDEV")] AlignStddev = 15,
        /// <summary>
        /// Align time series via aggregation. The resulting data point in
        /// the alignment period is the count of True-valued data points in the
        /// period. This alignment is valid for gauge metrics with
        /// Boolean values. The value type of the output is
        /// [INT64][google.api.MetricDescriptor.ValueType.INT64].
        /// </summary>
        [pbr::OriginalName("ALIGN_COUNT_TRUE")] AlignCountTrue = 16,
        /// <summary>
        /// Align time series via aggregation. The resulting data point in
        /// the alignment period is the fraction of True-valued data points in the
        /// period. This alignment is valid for gauge metrics with Boolean values.
        /// The output value is in the range [0, 1] and has value type
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
        /// </summary>
        [pbr::OriginalName("ALIGN_FRACTION_TRUE")] AlignFractionTrue = 17,
        /// <summary>
        /// Align time series via aggregation. The resulting data point in
        /// the alignment period is the 99th percentile of all data
        /// points in the period. This alignment is valid for gauge and delta metrics
        /// with distribution values. The output is a gauge metric with value type
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
        /// </summary>
        [pbr::OriginalName("ALIGN_PERCENTILE_99")] AlignPercentile99 = 18,
        /// <summary>
        /// Align time series via aggregation. The resulting data point in
        /// the alignment period is the 95th percentile of all data
        /// points in the period. This alignment is valid for gauge and delta metrics
        /// with distribution values. The output is a gauge metric with value type
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
        /// </summary>
        [pbr::OriginalName("ALIGN_PERCENTILE_95")] AlignPercentile95 = 19,
        /// <summary>
        /// Align time series via aggregation. The resulting data point in
        /// the alignment period is the 50th percentile of all data
        /// points in the period. This alignment is valid for gauge and delta metrics
        /// with distribution values. The output is a gauge metric with value type
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
        /// </summary>
        [pbr::OriginalName("ALIGN_PERCENTILE_50")] AlignPercentile50 = 20,
        /// <summary>
        /// Align time series via aggregation. The resulting data point in
        /// the alignment period is the 5th percentile of all data
        /// points in the period. This alignment is valid for gauge and delta metrics
        /// with distribution values. The output is a gauge metric with value type
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
        /// </summary>
        [pbr::OriginalName("ALIGN_PERCENTILE_05")] AlignPercentile05 = 21,
        [pbr::OriginalName("ALIGN_PERCENT_CHANGE")] AlignPercentChange = 23,
        [pbr::OriginalName("ALIGN_COUNT_FALSE")] AlignCountFalse = 24,
      }

      /// <summary>
      /// A Reducer describes how to aggregate data points from multiple
      /// time series into a single time series.
      /// </summary>
      public enum Reducer {
        /// <summary>
        /// No cross-time series reduction. The output of the aligner is
        /// returned.
        /// </summary>
        [pbr::OriginalName("REDUCE_NONE")] ReduceNone = 0,
        /// <summary>
        /// Reduce by computing the mean across time series for each
        /// alignment period. This reducer is valid for delta and
        /// gauge metrics with numeric or distribution values. The value type of the
        /// output is [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
        /// </summary>
        [pbr::OriginalName("REDUCE_MEAN")] ReduceMean = 1,
        /// <summary>
        /// Reduce by computing the minimum across time series for each
        /// alignment period. This reducer is valid for delta and
        /// gauge metrics with numeric values. The value type of the output
        /// is the same as the value type of the input.
        /// </summary>
        [pbr::OriginalName("REDUCE_MIN")] ReduceMin = 2,
        /// <summary>
        /// Reduce by computing the maximum across time series for each
        /// alignment period. This reducer is valid for delta and
        /// gauge metrics with numeric values. The value type of the output
        /// is the same as the value type of the input.
        /// </summary>
        [pbr::OriginalName("REDUCE_MAX")] ReduceMax = 3,
        /// <summary>
        /// Reduce by computing the sum across time series for each
        /// alignment period. This reducer is valid for delta and
        /// gauge metrics with numeric and distribution values. The value type of
        /// the output is the same as the value type of the input.
        /// </summary>
        [pbr::OriginalName("REDUCE_SUM")] ReduceSum = 4,
        /// <summary>
        /// Reduce by computing the standard deviation across time series
        /// for each alignment period. This reducer is valid for delta
        /// and gauge metrics with numeric or distribution values. The value type of
        /// the output is [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
        /// </summary>
        [pbr::OriginalName("REDUCE_STDDEV")] ReduceStddev = 5,
        /// <summary>
        /// Reduce by computing the count of data points across time series
        /// for each alignment period. This reducer is valid for delta
        /// and gauge metrics of numeric, Boolean, distribution, and string value
        /// type. The value type of the output is
        /// [INT64][google.api.MetricDescriptor.ValueType.INT64].
        /// </summary>
        [pbr::OriginalName("REDUCE_COUNT")] ReduceCount = 6,
        /// <summary>
        /// Reduce by computing the count of True-valued data points across time
        /// series for each alignment period. This reducer is valid for delta
        /// and gauge metrics of Boolean value type. The value type of
        /// the output is [INT64][google.api.MetricDescriptor.ValueType.INT64].
        /// </summary>
        [pbr::OriginalName("REDUCE_COUNT_TRUE")] ReduceCountTrue = 7,
        /// <summary>
        /// Reduce by computing the fraction of True-valued data points across time
        /// series for each alignment period. This reducer is valid for delta
        /// and gauge metrics of Boolean value type. The output value is in the
        /// range [0, 1] and has value type
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
        /// </summary>
        [pbr::OriginalName("REDUCE_FRACTION_TRUE")] ReduceFractionTrue = 8,
        /// <summary>
        /// Reduce by computing 99th percentile of data points across time series
        /// for each alignment period. This reducer is valid for gauge and delta
        /// metrics of numeric and distribution type. The value of the output is
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE]
        /// </summary>
        [pbr::OriginalName("REDUCE_PERCENTILE_99")] ReducePercentile99 = 9,
        /// <summary>
        /// Reduce by computing 95th percentile of data points across time series
        /// for each alignment period. This reducer is valid for gauge and delta
        /// metrics of numeric and distribution type. The value of the output is
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE]
        /// </summary>
        [pbr::OriginalName("REDUCE_PERCENTILE_95")] ReducePercentile95 = 10,
        /// <summary>
        /// Reduce by computing 50th percentile of data points across time series
        /// for each alignment period. This reducer is valid for gauge and delta
        /// metrics of numeric and distribution type. The value of the output is
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE]
        /// </summary>
        [pbr::OriginalName("REDUCE_PERCENTILE_50")] ReducePercentile50 = 11,
        /// <summary>
        /// Reduce by computing 5th percentile of data points across time series
        /// for each alignment period. This reducer is valid for gauge and delta
        /// metrics of numeric and distribution type. The value of the output is
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE]
        /// </summary>
        [pbr::OriginalName("REDUCE_PERCENTILE_05")] ReducePercentile05 = 12,
        [pbr::OriginalName("REDUCE_COUNT_FALSE")] ReduceCountFalse = 15,
      }

    }
    #endregion

  }

  /// <summary>
  /// Describes a ranking-based time series filter. Each input time series is
  /// ranked with an aligner. The filter lets through up to `num_time_series` time
  /// series, selecting them based on the relative ranking.
  /// </summary>
  public sealed partial class PickTimeSeriesFilter : pb::IMessage<PickTimeSeriesFilter> {
    private static readonly pb::MessageParser<PickTimeSeriesFilter> _parser = new pb::MessageParser<PickTimeSeriesFilter>(() => new PickTimeSeriesFilter());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PickTimeSeriesFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Monitoring.V3.CommonReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickTimeSeriesFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickTimeSeriesFilter(PickTimeSeriesFilter other) : this() {
      rankingMethod_ = other.rankingMethod_;
      numTimeSeries_ = other.numTimeSeries_;
      direction_ = other.direction_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickTimeSeriesFilter Clone() {
      return new PickTimeSeriesFilter(this);
    }

    /// <summary>Field number for the "ranking_method" field.</summary>
    public const int RankingMethodFieldNumber = 1;
    private global::Google.Cloud.Monitoring.V3.PickTimeSeriesFilter.Types.Method rankingMethod_ = 0;
    /// <summary>
    /// `rankingMethod` is applied to each time series independently to produce the
    /// value which will be used to compare the time series to other time series.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.V3.PickTimeSeriesFilter.Types.Method RankingMethod {
      get { return rankingMethod_; }
      set {
        rankingMethod_ = value;
      }
    }

    /// <summary>Field number for the "num_time_series" field.</summary>
    public const int NumTimeSeriesFieldNumber = 2;
    private int numTimeSeries_;
    /// <summary>
    /// How many time series to return.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumTimeSeries {
      get { return numTimeSeries_; }
      set {
        numTimeSeries_ = value;
      }
    }

    /// <summary>Field number for the "direction" field.</summary>
    public const int DirectionFieldNumber = 3;
    private global::Google.Cloud.Monitoring.V3.PickTimeSeriesFilter.Types.Direction direction_ = 0;
    /// <summary>
    /// How to use the ranking to select time series that pass through the filter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.V3.PickTimeSeriesFilter.Types.Direction Direction {
      get { return direction_; }
      set {
        direction_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PickTimeSeriesFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PickTimeSeriesFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (RankingMethod != other.RankingMethod) return false;
      if (NumTimeSeries != other.NumTimeSeries) return false;
      if (Direction != other.Direction) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (RankingMethod != 0) hash ^= RankingMethod.GetHashCode();
      if (NumTimeSeries != 0) hash ^= NumTimeSeries.GetHashCode();
      if (Direction != 0) hash ^= Direction.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (RankingMethod != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) RankingMethod);
      }
      if (NumTimeSeries != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(NumTimeSeries);
      }
      if (Direction != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Direction);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (RankingMethod != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RankingMethod);
      }
      if (NumTimeSeries != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumTimeSeries);
      }
      if (Direction != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Direction);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PickTimeSeriesFilter other) {
      if (other == null) {
        return;
      }
      if (other.RankingMethod != 0) {
        RankingMethod = other.RankingMethod;
      }
      if (other.NumTimeSeries != 0) {
        NumTimeSeries = other.NumTimeSeries;
      }
      if (other.Direction != 0) {
        Direction = other.Direction;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            rankingMethod_ = (global::Google.Cloud.Monitoring.V3.PickTimeSeriesFilter.Types.Method) input.ReadEnum();
            break;
          }
          case 16: {
            NumTimeSeries = input.ReadInt32();
            break;
          }
          case 24: {
            direction_ = (global::Google.Cloud.Monitoring.V3.PickTimeSeriesFilter.Types.Direction) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the PickTimeSeriesFilter message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// The value reducers that can be applied to a PickTimeSeriesFilter.
      /// </summary>
      public enum Method {
        /// <summary>
        /// Not allowed in well-formed requests.
        /// </summary>
        [pbr::OriginalName("METHOD_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Select the mean of all values.
        /// </summary>
        [pbr::OriginalName("METHOD_MEAN")] Mean = 1,
        /// <summary>
        /// Select the maximum value.
        /// </summary>
        [pbr::OriginalName("METHOD_MAX")] Max = 2,
        /// <summary>
        /// Select the minimum value.
        /// </summary>
        [pbr::OriginalName("METHOD_MIN")] Min = 3,
        /// <summary>
        /// Compute the sum of all values.
        /// </summary>
        [pbr::OriginalName("METHOD_SUM")] Sum = 4,
        /// <summary>
        /// Select the most recent value.
        /// </summary>
        [pbr::OriginalName("METHOD_LATEST")] Latest = 5,
      }

      /// <summary>
      /// Describes the ranking directions.
      /// </summary>
      public enum Direction {
        /// <summary>
        /// Not allowed in well-formed requests.
        /// </summary>
        [pbr::OriginalName("DIRECTION_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Pass the highest ranking inputs.
        /// </summary>
        [pbr::OriginalName("TOP")] Top = 1,
        /// <summary>
        /// Pass the lowest ranking inputs.
        /// </summary>
        [pbr::OriginalName("BOTTOM")] Bottom = 2,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
